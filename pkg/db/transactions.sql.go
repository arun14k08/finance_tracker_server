// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transactions.sql

package db

import (
	"context"
	"database/sql"

	"github.com/sqlc-dev/pqtype"
)

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions 
(account_id, amount, type, description, category, status, reference_id, metadata, initiated_by_user, related_account_id, is_self_transfer, merchant_id)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12)
RETURNING id, account_id, amount, type, description, category, status, reference_id, metadata, initiated_by_user, related_account_id, is_self_transfer, merchant_id, created_at, updated_at
`

type CreateTransactionParams struct {
	AccountID        int64
	Amount           string
	Type             string
	Description      sql.NullString
	Category         sql.NullString
	Status           sql.NullString
	ReferenceID      sql.NullString
	Metadata         pqtype.NullRawMessage
	InitiatedByUser  sql.NullBool
	RelatedAccountID sql.NullInt64
	IsSelfTransfer   sql.NullBool
	MerchantID       sql.NullInt64
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, createTransaction,
		arg.AccountID,
		arg.Amount,
		arg.Type,
		arg.Description,
		arg.Category,
		arg.Status,
		arg.ReferenceID,
		arg.Metadata,
		arg.InitiatedByUser,
		arg.RelatedAccountID,
		arg.IsSelfTransfer,
		arg.MerchantID,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Amount,
		&i.Type,
		&i.Description,
		&i.Category,
		&i.Status,
		&i.ReferenceID,
		&i.Metadata,
		&i.InitiatedByUser,
		&i.RelatedAccountID,
		&i.IsSelfTransfer,
		&i.MerchantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSelfTransfersByUser = `-- name: GetSelfTransfersByUser :many
SELECT t.id, account_id, amount, type, description, category, status, reference_id, metadata, initiated_by_user, related_account_id, is_self_transfer, merchant_id, t.created_at, t.updated_at, a.id, user_id, name, balance, account_type, currency, bank_name, last_four, is_active, nickname, notes, a.created_at, a.updated_at FROM transactions t
JOIN accounts a ON t.account_id = a.id
WHERE a.user_id = $1 AND t.is_self_transfer = TRUE
ORDER BY t.created_at DESC
LIMIT $2
`

type GetSelfTransfersByUserParams struct {
	UserID int64
	Limit  int32
}

type GetSelfTransfersByUserRow struct {
	ID               int64
	AccountID        int64
	Amount           string
	Type             string
	Description      sql.NullString
	Category         sql.NullString
	Status           sql.NullString
	ReferenceID      sql.NullString
	Metadata         pqtype.NullRawMessage
	InitiatedByUser  sql.NullBool
	RelatedAccountID sql.NullInt64
	IsSelfTransfer   sql.NullBool
	MerchantID       sql.NullInt64
	CreatedAt        sql.NullTime
	UpdatedAt        sql.NullTime
	ID_2             int64
	UserID           int64
	Name             string
	Balance          string
	AccountType      sql.NullString
	Currency         sql.NullString
	BankName         string
	LastFour         string
	IsActive         sql.NullBool
	Nickname         sql.NullString
	Notes            sql.NullString
	CreatedAt_2      sql.NullTime
	UpdatedAt_2      sql.NullTime
}

func (q *Queries) GetSelfTransfersByUser(ctx context.Context, arg GetSelfTransfersByUserParams) ([]GetSelfTransfersByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getSelfTransfersByUser, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSelfTransfersByUserRow
	for rows.Next() {
		var i GetSelfTransfersByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Amount,
			&i.Type,
			&i.Description,
			&i.Category,
			&i.Status,
			&i.ReferenceID,
			&i.Metadata,
			&i.InitiatedByUser,
			&i.RelatedAccountID,
			&i.IsSelfTransfer,
			&i.MerchantID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.UserID,
			&i.Name,
			&i.Balance,
			&i.AccountType,
			&i.Currency,
			&i.BankName,
			&i.LastFour,
			&i.IsActive,
			&i.Nickname,
			&i.Notes,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT id, account_id, amount, type, description, category, status, reference_id, metadata, initiated_by_user, related_account_id, is_self_transfer, merchant_id, created_at, updated_at FROM transactions
WHERE id = $1
`

func (q *Queries) GetTransactionByID(ctx context.Context, id int64) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByID, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Amount,
		&i.Type,
		&i.Description,
		&i.Category,
		&i.Status,
		&i.ReferenceID,
		&i.Metadata,
		&i.InitiatedByUser,
		&i.RelatedAccountID,
		&i.IsSelfTransfer,
		&i.MerchantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionsByAccount = `-- name: GetTransactionsByAccount :many
SELECT id, account_id, amount, type, description, category, status, reference_id, metadata, initiated_by_user, related_account_id, is_self_transfer, merchant_id, created_at, updated_at FROM transactions
WHERE account_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetTransactionsByAccountParams struct {
	AccountID int64
	Limit     int32
}

func (q *Queries) GetTransactionsByAccount(ctx context.Context, arg GetTransactionsByAccountParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByAccount, arg.AccountID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Amount,
			&i.Type,
			&i.Description,
			&i.Category,
			&i.Status,
			&i.ReferenceID,
			&i.Metadata,
			&i.InitiatedByUser,
			&i.RelatedAccountID,
			&i.IsSelfTransfer,
			&i.MerchantID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByMerchant = `-- name: GetTransactionsByMerchant :many
SELECT id, account_id, amount, type, description, category, status, reference_id, metadata, initiated_by_user, related_account_id, is_self_transfer, merchant_id, created_at, updated_at FROM transactions
WHERE merchant_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetTransactionsByMerchantParams struct {
	MerchantID sql.NullInt64
	Limit      int32
}

func (q *Queries) GetTransactionsByMerchant(ctx context.Context, arg GetTransactionsByMerchantParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByMerchant, arg.MerchantID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Amount,
			&i.Type,
			&i.Description,
			&i.Category,
			&i.Status,
			&i.ReferenceID,
			&i.Metadata,
			&i.InitiatedByUser,
			&i.RelatedAccountID,
			&i.IsSelfTransfer,
			&i.MerchantID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
